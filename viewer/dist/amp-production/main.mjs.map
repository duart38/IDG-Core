{"version":3,"file":"main.mjs","sources":["../../output/main-thread/commands/event-subscription.js","../../output/main-thread/serialize.js","../../output/main-thread/iframe-worker.js","../../output/main-thread/install.js","../../output/main-thread/index.amp.js"],"sourcesContent":["/**\n * Copyright 2018 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ADD_EVENT_SUBSCRIPTION_LENGTH, REMOVE_EVENT_SUBSCRIPTION_LENGTH, } from '../../transfer/TransferrableEvent';\nimport { BASE_ELEMENT_INDEX } from '../nodes';\n/**\n * Monitoring Nodes attribute changes requires a Mutation Observer.\n * We store the nodes being monitored to avoid creating more than one Observer\n * per Element.\n */\nconst monitoredNodes = new Map();\n/**\n * Instead of a whitelist of elements that need their value tracked, use the existence\n * of a property called value to drive the decision.\n * @param node node to check if values should be tracked.\n * @return boolean if the node should have its value property tracked.\n */\nconst shouldTrackChanges = (node) => node && 'value' in node;\n/**\n * When a node that has a value needing synced doesn't already have an event listener\n * listening for input values, ensure the value is synced with a default listener.\n * @param worker whom to dispatch value toward.\n * @param node node to listen to value changes on.\n */\nexport const applyDefaultInputListener = (workerContext, node) => {\n    if (shouldTrackChanges(node) && node.oninput === null) {\n        node.oninput = () => fireValueChange(workerContext, node);\n    }\n};\n/**\n * Use a MutationObserver to capture value changes based on Attribute modification (frequently used by frameworks).\n * @param worker whom to dispatch value toward.\n * @param node node to listen to value changes on.\n */\nexport const sendValueChangeOnAttributeMutation = (workerContext, node) => {\n    if (shouldTrackChanges(node) && !monitoredNodes.get(node)) {\n        new MutationObserver((mutations) => mutations.map((mutation) => fireValueChange(workerContext, mutation.target))).observe(node, { attributes: true });\n        monitoredNodes.set(node, true);\n    }\n};\n/**\n * Tell WorkerDOM what the value is for a Node.\n * @param worker whom to dispatch value toward.\n * @param node where to get the value from.\n */\nconst fireValueChange = (workerContext, node) => workerContext.messageToWorker({\n    [12 /* type */]: 4 /* SYNC */,\n    [40 /* sync */]: {\n        [7 /* index */]: node._index_,\n        [21 /* value */]: node.value,\n    },\n});\n/**\n * Tell WorkerDOM what the window dimensions are.\n * @param workerContext\n * @param cachedWindowSize\n */\nconst fireResizeChange = (workerContext, cachedWindowSize) => workerContext.messageToWorker({\n    [12 /* type */]: 5 /* RESIZE */,\n    [40 /* sync */]: cachedWindowSize,\n});\n/**\n * Convert a TouchList into a TransferrableTouchList\n * @param touchList\n */\nconst createTransferrableTouchList = (touchList) => Object.values(touchList).map((touch) => [\n    touch.identifier,\n    touch.screenX,\n    touch.screenY,\n    touch.clientX,\n    touch.clientY,\n    touch.pageX,\n    touch.pageY,\n    touch.target._index_,\n]);\nexport const EventSubscriptionProcessor = (strings, nodeContext, workerContext, objectContext, config) => {\n    const knownListeners = [];\n    const allowedExecution = config.executorsAllowed.includes(4 /* EVENT_SUBSCRIPTION */);\n    let cachedWindowSize = [window.innerWidth, window.innerHeight];\n    /**\n     * Register an event handler for dispatching events to worker thread\n     * @param worker whom to dispatch events toward\n     * @param index node index the event comes from (used to dispatchEvent in worker thread).\n     * @return eventHandler function consuming event and dispatching to worker thread\n     */\n    const eventHandler = (index, preventDefault) => (event) => {\n        if (preventDefault) {\n            event.preventDefault();\n        }\n        if (shouldTrackChanges(event.currentTarget)) {\n            fireValueChange(workerContext, event.currentTarget);\n        }\n        else if (event.type === 'resize') {\n            const { innerWidth, innerHeight } = window;\n            if (cachedWindowSize[0] === innerWidth && cachedWindowSize[1] === innerHeight) {\n                return;\n            }\n            cachedWindowSize = [window.innerWidth, window.innerHeight];\n            fireResizeChange(workerContext, cachedWindowSize);\n        }\n        workerContext.messageToWorker({\n            [12 /* type */]: 1 /* EVENT */,\n            [39 /* event */]: {\n                [7 /* index */]: index,\n                [25 /* bubbles */]: event.bubbles,\n                [26 /* cancelable */]: event.cancelable,\n                [27 /* cancelBubble */]: event.cancelBubble,\n                [28 /* currentTarget */]: [event.currentTarget._index_ || 0],\n                [29 /* defaultPrevented */]: event.defaultPrevented,\n                [30 /* eventPhase */]: event.eventPhase,\n                [31 /* isTrusted */]: event.isTrusted,\n                [32 /* returnValue */]: event.returnValue,\n                [13 /* target */]: [event.target._index_ || 0],\n                [33 /* timeStamp */]: event.timeStamp,\n                [12 /* type */]: event.type,\n                [35 /* keyCode */]: 'keyCode' in event ? event.keyCode : undefined,\n                [60 /* pageX */]: 'pageX' in event ? event.pageX : undefined,\n                [61 /* pageY */]: 'pageY' in event ? event.pageY : undefined,\n                [65 /* offsetX */]: 'offsetX' in event ? event.offsetX : undefined,\n                [66 /* offsetY */]: 'offsetY' in event ? event.offsetY : undefined,\n                [62 /* touches */]: 'touches' in event ? createTransferrableTouchList(event.touches) : undefined,\n                [63 /* changedTouches */]: 'changedTouches' in event ? createTransferrableTouchList(event.changedTouches) : undefined,\n            },\n        });\n    };\n    /**\n     * If the worker requests to add an event listener to 'change' for something the foreground thread is already listening to,\n     * ensure that only a single 'change' event is attached to prevent sending values multiple times.\n     * @param target node to change listeners on\n     * @param addEvent is this an 'addEvent' or 'removeEvent' change\n     * @param mutations Uint16Array for this set of changes\n     * @param iterator current location in array to perform this change on\n     */\n    const processListenerChange = (target, addEvent, mutations, iterator) => {\n        const type = strings.get(mutations[iterator]);\n        const eventIndex = mutations[iterator + 1 /* Index */];\n        if (target === nodeContext.baseElement) {\n            if (addEvent) {\n                const preventDefault = Boolean(mutations[iterator + 5 /* WorkerDOMPreventDefault */]);\n                addEventListener(type, (knownListeners[eventIndex] = eventHandler(BASE_ELEMENT_INDEX, preventDefault)));\n            }\n            else {\n                removeEventListener(type, knownListeners[eventIndex]);\n            }\n            return;\n        }\n        let inputEventSubscribed = target.oninput !== null;\n        const isChangeEvent = type === 'change';\n        if (addEvent) {\n            if (isChangeEvent) {\n                inputEventSubscribed = true;\n                target.onchange = null;\n            }\n            const preventDefault = Boolean(mutations[iterator + 5 /* WorkerDOMPreventDefault */]);\n            target.addEventListener(type, (knownListeners[eventIndex] = eventHandler(target._index_, preventDefault)));\n        }\n        else {\n            if (isChangeEvent) {\n                inputEventSubscribed = false;\n            }\n            target.removeEventListener(type, knownListeners[eventIndex]);\n        }\n        if (shouldTrackChanges(target)) {\n            if (!inputEventSubscribed)\n                applyDefaultInputListener(workerContext, target);\n            sendValueChangeOnAttributeMutation(workerContext, target);\n        }\n    };\n    return {\n        execute(mutations, startPosition, allowedMutation) {\n            const addEventListenerCount = mutations[startPosition + 3 /* AddEventListenerCount */];\n            const removeEventListenerCount = mutations[startPosition + 2 /* RemoveEventListenerCount */];\n            const addEventListenersPosition = startPosition + 4 /* Events */ + removeEventListenerCount * REMOVE_EVENT_SUBSCRIPTION_LENGTH;\n            const endPosition = startPosition +\n                4 /* Events */ +\n                addEventListenerCount * ADD_EVENT_SUBSCRIPTION_LENGTH +\n                removeEventListenerCount * REMOVE_EVENT_SUBSCRIPTION_LENGTH;\n            if (allowedExecution && allowedMutation) {\n                const targetIndex = mutations[startPosition + 1 /* Target */];\n                const target = nodeContext.getNode(targetIndex);\n                if (target) {\n                    let iterator = startPosition + 4 /* Events */;\n                    while (iterator < endPosition) {\n                        const isRemoveEvent = iterator <= addEventListenersPosition;\n                        processListenerChange(target, isRemoveEvent, mutations, iterator);\n                        iterator += isRemoveEvent ? REMOVE_EVENT_SUBSCRIPTION_LENGTH : ADD_EVENT_SUBSCRIPTION_LENGTH;\n                    }\n                }\n                else {\n                    console.error(`getNode(${targetIndex}) is null.`);\n                }\n            }\n            return endPosition;\n        },\n        print(mutations, startPosition) {\n            const addEventListenerCount = mutations[startPosition + 3 /* AddEventListenerCount */];\n            const removeEventListenerCount = mutations[startPosition + 2 /* RemoveEventListenerCount */];\n            const addEventListenersPosition = startPosition + 4 /* Events */ + removeEventListenerCount * REMOVE_EVENT_SUBSCRIPTION_LENGTH;\n            const endPosition = startPosition +\n                4 /* Events */ +\n                addEventListenerCount * ADD_EVENT_SUBSCRIPTION_LENGTH +\n                removeEventListenerCount * REMOVE_EVENT_SUBSCRIPTION_LENGTH;\n            const targetIndex = mutations[startPosition + 1 /* Target */];\n            const target = nodeContext.getNode(targetIndex);\n            const removedEventListeners = [];\n            const addedEventListeners = [];\n            let iterator = startPosition + 4 /* Events */;\n            while (iterator < endPosition) {\n                const isRemoveEvent = iterator <= addEventListenersPosition;\n                const eventList = isRemoveEvent ? addedEventListeners : removedEventListeners;\n                eventList.push({\n                    type: strings.get(mutations[iterator]),\n                    index: mutations[iterator + 1],\n                });\n                iterator += isRemoveEvent ? REMOVE_EVENT_SUBSCRIPTION_LENGTH : ADD_EVENT_SUBSCRIPTION_LENGTH;\n            }\n            return {\n                target,\n                allowedExecution,\n                removedEventListeners,\n                addedEventListeners,\n            };\n        },\n    };\n};\n//# sourceMappingURL=event-subscription.js.map","/**\n * Copyright 2018 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { applyDefaultInputListener, sendValueChangeOnAttributeMutation } from './commands/event-subscription';\nconst NODES_ALLOWED_TO_TRANSMIT_TEXT_CONTENT = [8 /* COMMENT_NODE */, 3 /* TEXT_NODE */];\n/**\n * Serializes a DOM element for transport to the worker.\n * @param element\n * @param minimizeString Function for minimizing strings for optimized ferrying across postMessage.\n */\nfunction createHydrateableNode(element, minimizeString, hydrateFilter, workerContext) {\n    const filteredChildNodes = [].slice.call(element.childNodes).filter(hydrateFilter);\n    const hydrated = {\n        [7 /* index */]: element._index_,\n        [11 /* transferred */]: 0 /* FALSE */,\n        [0 /* nodeType */]: element.nodeType,\n        [1 /* localOrNodeName */]: minimizeString(element.localName || element.nodeName),\n        [4 /* childNodes */]: filteredChildNodes.map((child) => createHydrateableNode(child, minimizeString, hydrateFilter, workerContext)),\n        [2 /* attributes */]: [].map.call(element.attributes || [], (attribute) => [\n            minimizeString(attribute.namespaceURI || 'null'),\n            minimizeString(attribute.name),\n            minimizeString(attribute.value),\n        ]),\n    };\n    if (element.namespaceURI != null) {\n        hydrated[6 /* namespaceURI */] = minimizeString(element.namespaceURI);\n    }\n    if (NODES_ALLOWED_TO_TRANSMIT_TEXT_CONTENT.includes(element.nodeType) && element.textContent !== null) {\n        hydrated[5 /* textContent */] = minimizeString(element.textContent);\n    }\n    applyDefaultInputListener(workerContext, element);\n    sendValueChangeOnAttributeMutation(workerContext, element);\n    return hydrated;\n}\n/**\n * @param element\n */\nexport function createHydrateableRootNode(element, config, workerContext) {\n    const hydrateFilter = config.hydrateFilter || (() => true);\n    const strings = [];\n    const stringMap = new Map();\n    const storeString = (value) => {\n        if (stringMap.has(value)) {\n            // Safe to cast since we verified the mapping contains the value.\n            return stringMap.get(value);\n        }\n        const count = strings.length;\n        stringMap.set(value, count);\n        strings.push(value);\n        return count;\n    };\n    const skeleton = createHydrateableNode(element, storeString, hydrateFilter, workerContext);\n    return { skeleton, strings };\n}\n/**\n * @param element\n */\nexport function createReadableHydrateableRootNode(element, config, workerContext) {\n    // \"Readable\" variant doesn't do any string minimization so we can output it for debugging purposes.\n    // Note that this intentionally breaks the type contract of createHydrateableNode() and HydrateableNode.\n    return createHydrateableNode(element, ((value) => value), config.hydrateFilter || (() => true), workerContext);\n}\n//# sourceMappingURL=serialize.js.map","/**\n * Copyright 2021 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An almost drop-in replacement for a standard Web Worker, although this one\n * within a sandboxed cross-origin iframe for a heightened security boundary.\n * For more details on Worker, see: https://developer.mozilla.org/en-US/docs/Web/API/Worker\n *\n * The iframe used for sandboxing must follow a specific contract. It:\n *   1. Must send a ready message to the main-thread.\n *   2. Must listen for a message from main-thread with the code to initialize a Worker with.\n *   3. Must send \"worker-ready\" once worker is initialized.\n *   4. Must proxy all messages between the Worker and Parent, including errors.\n */\nclass IframeWorker {\n    url;\n    // Public Worker API\n    onerror;\n    onmessage;\n    onmessageerror;\n    readyPromise;\n    // Internal variables.\n    iframe;\n    readyPromiseResolve;\n    /**\n     * @param url The URL to initiate the worker from.\n     * @param iframeUrl The URL of the iframe to use as the worker proxy.\n     */\n    constructor(url, iframeUrl) {\n        this.url = url;\n        this.iframe = window.document.createElement('iframe');\n        this.iframe.setAttribute('sandbox', 'allow-scripts');\n        this.iframe.setAttribute('style', 'display:none');\n        this.iframe.setAttribute('src', iframeUrl);\n        this.url = url;\n        this.readyPromise = new Promise((resolve) => {\n            this.readyPromiseResolve = resolve;\n        });\n        this.setupInit();\n        this.proxyFromWorker();\n        window.document.body.appendChild(this.iframe);\n    }\n    setupInit() {\n        const listener = (event) => {\n            if (event.source != this.iframe.contentWindow) {\n                return;\n            }\n            fetch(this.url.toString())\n                .then((res) => res.text())\n                .then((code) => {\n                const data = event.data;\n                if (data.type == 'iframe-ready') {\n                    const msg = { type: 'init-worker', code };\n                    this.iframe.contentWindow.postMessage(msg, '*');\n                }\n                else if (data.type === 'worker-ready') {\n                    this.readyPromiseResolve();\n                    window.removeEventListener('message', listener);\n                }\n            });\n        };\n        window.addEventListener('message', listener);\n    }\n    proxyFromWorker() {\n        window.addEventListener('message', (event) => {\n            if (event.source != this.iframe.contentWindow) {\n                return;\n            }\n            const { type, message } = event.data;\n            if (type == 'onmessage' && this.onmessage) {\n                this.onmessage({ ...event, data: message });\n            }\n            else if (type === 'onerror' && this.onerror) {\n                this.onerror(message);\n            }\n            else if (type === 'onmessageerror' && this.onmessageerror) {\n                this.onmessageerror({ ...event, data: message });\n            }\n        });\n    }\n    /**\n     * See https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage\n     * @param message\n     * @param transferables\n     */\n    postMessage(message, transferables) {\n        const msg = { type: 'postMessage', message };\n        this.readyPromise.then(() => {\n            this.iframe.contentWindow.postMessage(msg, '*', transferables);\n        });\n    }\n    /**\n     * See https://developer.mozilla.org/en-US/docs/Web/API/Worker/terminate\n     */\n    terminate() {\n        const msg = { type: 'terminate' };\n        this.iframe.contentWindow.postMessage(msg, '*');\n        this.iframe.remove();\n    }\n}\nexport { IframeWorker };\n//# sourceMappingURL=iframe-worker.js.map","/**\n * Copyright 2018 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { MutatorProcessor } from './mutator';\nimport { NodeContext } from './nodes';\nimport { StringContext } from './strings';\nimport { normalizeConfiguration } from './configuration';\nimport { WorkerContext } from './worker';\nimport { ObjectContext } from './object-context';\nimport { ExportedWorker } from './exported-worker';\nconst ALLOWABLE_MESSAGE_TYPES = [3 /* MUTATE */, 2 /* HYDRATE */];\n/**\n * @param baseElement\n * @param authorScriptURL\n * @param workerDOMURL\n * @param callbacks\n * @param sanitizer\n * @param debug\n */\nexport function fetchAndInstall(baseElement, config) {\n    const fetchPromise = Promise.all([\n        // TODO(KB): Fetch Polyfill for IE11.\n        fetch(config.domURL).then((response) => response.text()),\n        fetch(config.authorURL).then((response) => response.text()),\n    ]);\n    return install(fetchPromise, baseElement, config);\n}\n/**\n * @param fetchPromise\n * @param baseElement\n * @param config\n */\nexport function install(fetchPromise, baseElement, config) {\n    const stringContext = new StringContext();\n    const objectContext = new ObjectContext();\n    const nodeContext = new NodeContext(stringContext, baseElement);\n    const normalizedConfig = normalizeConfiguration(config);\n    return fetchPromise.then(([domScriptContent, authorScriptContent]) => {\n        if (domScriptContent && authorScriptContent && config.authorURL) {\n            const workerContext = new WorkerContext(baseElement, nodeContext, domScriptContent, authorScriptContent, normalizedConfig);\n            const mutatorContext = new MutatorProcessor(stringContext, nodeContext, workerContext, normalizedConfig, objectContext);\n            workerContext.worker.onmessage = (message) => {\n                const { data } = message;\n                if (!ALLOWABLE_MESSAGE_TYPES.includes(data[12 /* type */])) {\n                    return;\n                }\n                mutatorContext.mutate(data[54 /* phase */], data[37 /* nodes */], data[41 /* strings */], new Uint16Array(data[36 /* mutations */]));\n                if (config.onReceiveMessage) {\n                    config.onReceiveMessage(message);\n                }\n            };\n            return workerContext.ready().then(() => new ExportedWorker(workerContext, normalizedConfig));\n        }\n        return null;\n    });\n}\n//# sourceMappingURL=install.js.map","/**\n * Copyright 2018 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview This entry point API in active development and unstable.\n */\nimport { fetchAndInstall, install } from './install';\nimport { toLower } from '../utils';\n/**\n * AMP Element Children need to be filtered from Hydration, to avoid Author Code from manipulating it.\n * TODO: In the future, this contract needs to be more defined.\n * @param element\n */\nconst hydrateFilter = (element) => {\n    if (element.parentNode !== null) {\n        const lowerName = toLower(element.parentNode.localName || element.parentNode.nodeName);\n        return !/amp-/.test(lowerName) || lowerName === 'amp-script';\n    }\n    return true;\n};\n/**\n * @param baseElement\n * @param domURL\n */\nexport function upgradeElement(baseElement, domURL, longTask, sanitizer, sandbox) {\n    const authorURL = baseElement.getAttribute('src');\n    if (authorURL) {\n        return fetchAndInstall(baseElement, {\n            domURL,\n            authorURL,\n            longTask,\n            hydrateFilter,\n            sanitizer,\n            sandbox,\n        });\n    }\n    return Promise.resolve(null);\n}\n/**\n * @param baseElement\n * @param fetchPromise Promise that resolves containing worker script, and author script.\n */\nexport function upgrade(baseElement, fetchPromise, config) {\n    config.hydrateFilter = hydrateFilter;\n    return install(fetchPromise, baseElement, config);\n}\n//# sourceMappingURL=index.amp.js.map"],"names":["d"],"mappings":"ysCAmCA,oZAAAA,qlNCZA,olBCWA,oiHCRA,gdCIA"}